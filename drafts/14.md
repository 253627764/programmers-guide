# Chapter  14: Advanced Topics
Wow! You are on the last chapter. Good Job! By now you should feel comfortable
creating your games with Cocos2d-x. However, please realize there is no limit to
what you can create. This chapter covers __advanced__ concepts. Note that this
chapter gets more technical in it's content and format.

# File System Access
Even though you can use functions in `stdio.h` to access files it can be
inconvenient for a few reasons:
* You need to invoke system specific API to get full path of a file.
* Resources are packed into .apk file on Android after installing.
* Want to load a resource(such as a picture) based on resolution automatically.

The `FileUtils` class has been created to resolve these issues. `FileUitls` is a
helper class to access files under `Resources`. This includes reading data from
a file and checking file existence.

### Functions to read file content
These functions will read different type of files and will return different data types:
```
| function name          | return type          | support path type               |
| getStringFromFile      | std::string          | relative path and absolute path |
| getDataFromFile        | cocos2d::Data        | relative path and absolute path |
| getFileDataFromZip     | unsigned char*       | absolute path                   |
| getValueMapFromFile    | cocos2d::ValueMap    | relative path and absolute path |
| getValueVectorFromFile | cocos2d::ValueVector | relative path and absolute path |
```

### Functions to manage files or directories
These functions will manage a file or a directory:
```
| function name         | support path type               |
| isFileExist           | relative path and absolute path |
| isDirectoryExist      | relative path and absolute path |
| createDirectory       | absolute path                   |
| removeDirectory       | absolute path                   |
| removeFile            | absolute path                   |
| renameFile            | absolute path                   |
| getFileSize           | relative path and absolute path |
```

# Networking with HTTP
Sometimes it might be helpful to obtain resources or data from another source.
One common way to do this is by using an `HTTP` request.

HTTP networking has three steps:
   1. Create an `HttpRequest`
   2. Create a `setResponseCallback()` callback function for replying to requests.
   3. Send `HttpRequest` by `HttpClient`

`HttpRequest` can have four types:  _POST_, _PUT_, _DELETE_, _UNKNOWN_. Unless
specified the default is _UNKNOWN_. `HTTPClient` controls sending the _request_
and receiving the data on a _callback_.

Working with an `HTTPRequest` is quite simple:
```cpp
HttpRequest* request = new (std :: nothrow) HttpRequest();
request->setUrl("http://just-make-this-request-failed.com");
request->setRequestType(HttpRequest::Type::GET);
request->setResponseCallback(CC_CALLBACK_2 (HttpClientTest::onHttpRequestCompleted, this));

HttpClient::getInstance()->sendImmediate(request);

request->release();
```

Notice that we specified a `setResponseCallback()` method for when a response is
received. By doing this we can look at the data returned and use it how we might
need to. Again, this process is simple and we can do it with ease:
```cpp
void HttpClientTest::onHttpRequestCompleted(HttpClient* sender, HttpResponse* response)
{
  if (!response)
  {
    return;
  }

  // Dump the data
  std::vector<char>* buffer = response->getResponseData();

  for (unsigned int i = 0; i <buffer-> size (); i ++)
  {
    log ("% c", (* buffer) [i]);
  }
}
```

### How to create auto batch friendly GUI
Before we digging into the solution, let's first talk a little bit about
auto batch itself.

Since Cocos2d-x v3.x, we introduced a new feature called "Auto batch drawing".
Now only *QuardCommand* and *TrianglesCommand* could be benefit from auto batch.

These two commands will have generated material ID by give textureID, glProgramstate
and Blend function. If the these three requirements are identical, then these
commands could be batched to save draw call.

One more important thing you should keep in mind that the batching commands must
be continuous, the renderer won't sort all these commands in the renderer queue.
And all rendering commands will be added to the render queue according to the scene
graph visiting order.

For better illustration,suppose we have two images: *A.png* and *B.png*.

Here are some sample code:

1. 
```cpp
for(int i=0; i<1000; i++)
{
    auto sprite = Sprite::create("A.png");
    this->addChild(sprite,1);
}

for(int i=0; i<1000; i++)
{
    auto sprite = Sprite::create("B.png");
    this->addChild(sprite,2);
}
```

*Result:*
> The final draw call would be 2.

2.

```cpp
for(int i=0; i<1000; i++)
{
    auto sprite = Sprite::create("A.png");
    this->addChild(sprite,1);
    auto sprite2 = Sprite::create("B.png");
    this->addChild(sprite2,2);
}
```

*Result:*
> The final draw call would be 2000.

As you see, the rendering visual result is the same, but the draw call differs
dramatically.

So how do we solve the problem? Spritesheet comes to rescue.

If we pack *A.png* and *B.png* into a large sprite atlas and create sprite from
the sprite atlas, then the above code snippet could be drawn in only one draw call.

If you want to create auto batch friendly GUI, you'd better pack the sprites of
related GUI widgets into one large sprite atlas. And cocos2d-x would take the test
work for you.

No big deal. You just need to group related sprites into spritesheet.

When you create GUI scene with CocosStudio, you should also consider the widget
order in the scene graph. If two widgets don't overlay visually, you should
organized them and make sure they are adjacent.

<!--
## Best Practice - Optimization, memory, performance, profiling

## SQLite

## Subclass Cocos2d-x classes

## Data structures (i.e Vector)

## Custom OpenGL (what to cover here? CustomCommand?)

## c++11 usage

## rendering pipeline (notes about this in the wiki)
-->
