# Chapter 7: UI

## Overview
In Cocos2d-x v3.x, we have three ways to deal with GUI programming.

- Label, Menu & MenuItem and TextFieldTTF, which have limited functions. But they are simple and easy to use.

- Control Extensions under extension module plus a simple ScrollView and TableView implementation. It also has a handy EditBox for text input

**Note**:(Now, Since v3.3 beta, the EditBox class has been moved to UI module and the original cocos2d::extensions::EditBox has been marked as DEPRECATED. In the future release of cocos2d-x, the ScrollView and TableView will also be DEPRECATED and we will provide alternative replacement in UI module.).

The Control Extensions exists mainly for CocosBuilder. The parser of CocosBuilder uses this module heavily. There is very handy class in Control Extensions named Scale9Sprite which could help drawing slice 9 enabled sprite on screen. Now the Scale9Sprite is also marked as DEPRECATED and a replacement is ui::Scale9Sprite which has full functionality of the original one plus more features.

- The brand new UI module. The recommended way to handling GUI programming in Cocos2d-x.

So which UI module should I choose when dealing with GUI programming in Cocos2d-x?

There is one rule:

> Always stick to the new UI module, because we also have an [UI editor](http://cocos2d-x.org/products#cocos-studio) to layout your UI elements visually.



## Label, Menu & MenuItem and TextFieldTTF
### Labels
Cocos2d-x v3 has unified the creation of Label into a single API.
There are a few different types of Labels you can choose from.
  
#### BMFont
`BMFont` is a label type that uses a bitmap font. Bitmap fonts consist of a matrix of dots or pixels representing the image of each glyph in each face and size. It is very faster and easy to use, but non-scalable, requiring a separate font for each size.

In order to create a BMFont label, we should provide two files: A fooBar.fnt file and a fooBar.png file.

```cpp
auto myLabel = cocos2d::Label::createWithBMFont("fooBar.fnt", "My Label Text");
```


#### TTF
`TTF` is a label type that uses a True Type Font. You must provide a True Type font file to feed the `Label::createWithTTF` function.

The primary strength of TrueType was originally that it offered font developers a high degree of control over precisely how their fonts are displayed, right down to particular pixels, at various font sizes.

When we create a TTF Label , it will create a 512 * 512 texture at first, when we change the Label text, it will search the character from the cached texture. If not found, it will create a new character and put it into the texture. When it reaches the limit of the texture, we will create another 512 * 512 texture and cache the new character in it. Thus we could keep the memory foot print as minimal as possible and also improve text rendering speed.

So it will not run as fast as BMFont when changing the Label content during game play frequently.

Here is the code to create a TTF Label with "myfont.ttf":

```cpp
auto myLabel = cocos2d::Label::createWithTTF("myfont.ttf", "My Label Text", 16);
```       

We could also use a more complex way to create TTF Labels:

```cpp
TTFConfig labelConfig;
labelConfig.fontFilePath = "myfont.ttf";
labelConfig.fontSize = 16;
//choose the glyphs, which includes DYNAMICï¼Œ NEHE, ASCII and CUSTOM now.
labelConfig.glyphs = GlyphCollection::DYNAMIC;
labelConfig.outlineSize = 0;
labelConfig.distanceFieldEnabled = false;
auto mylabel = cocos2d::Label::createWithTTF(labelConfig, "My Label Text");
```

So it mainly be used for displaying Chart message or some static text information.


#### Label Atlas
`Label Atlas` is a label type that uses texture atlas.

```cpp
auto mylabl = cocos2d::Label::createWithCharMap("fonts/labelatlasimg.png",24,32,'0');
```

Here is the charmap png file, its dimension is 240 * 32 and it contains 10 numbers from 0-9, so each number occupy 24*32.

The 2rd and 3rd arguments of `Label::createWithCharMap` is the itemWith and itemHeight.

![charmap](7/labelatlasimg.png)

You could consider Label Atlas as a simple BMFont with limited font customization. It runs as fast as BMFont and usually used for displaying rapid changing game scores.

         
#### SystemFont
`SystemFont` is a label type that usese the default system font and font size. 

```cpp
auto myLabel3 = cocos2d::Label::createWithSystemFont("My Label Text", "Arial", 16);
```

    


#### Shadow, Outline and Glow
The new Label supports Shadow, Outline and Glow effect, here are the APIs to enable this effect:

```cpp
    /**
     * Enable shadow for the label
     *
     * @todo support blur for shadow effect
     */
    virtual void enableShadow(const Color4B& shadowColor = Color4B::BLACK,const Size &offset = Size(2,-2), int blurRadius = 0);

    /** only support for TTF, the System Font Outline effect only works on Android and IOS
    virtual void enableOutline(const Color4B& outlineColor,int outlineSize = -1);

    /** only support for TTF */
    virtual void enableGlow(const Color4B& glowColor);
```

As we see from the comments part, the Shadow effect is supported for all kind of Label types, but Outline effect only works well on all platform with TTF font, the SystemFont Outline effect only supports IOS and Android and the Glow effect only works with TTF font. That's because we use FreeType2 to rendering TTF font on various platform since v3.0.

#### Text Alignment
The new label support Horizontal and Vertical text alignment. The APIs are very straightforward:

```cpp
    void setAlignment(TextHAlignment hAlignment) { setAlignment(hAlignment,_vAlignment);}
    TextHAlignment getTextAlignment() const { return _hAlignment;}

    void setAlignment(TextHAlignment hAlignment,TextVAlignment vAlignment);

    void setHorizontalAlignment(TextHAlignment hAlignment) { setAlignment(hAlignment,_vAlignment); }
    TextHAlignment getHorizontalAlignment() const { return _hAlignment; }

    void setVerticalAlignment(TextVAlignment vAlignment) { setAlignment(_hAlignment,vAlignment); }
    TextVAlignment getVerticalAlignment() const { return _vAlignment; }
```
#### Line Wrap
The new label also supports *Line Wrap*, you could specify a dimension to your label, when a text line reach the boundary of the dimension, it will automatically break the current line.

```cpp
    /** Sets the untransformed size of the label.
     * The label's width be used for text align if the set value not equal zero.
     * The label's max line width will be equal to the same value.
     */
    void setWidth(unsigned int width) { setDimensions(width,_labelHeight);}
    unsigned int getWidth() const { return _labelWidth; }  

    /** Sets the untransformed size of the label.
     * The label's height be used for text align if the set value not equal zero.
     * The text will display of incomplete when the size of label not enough to support display all text.
     */
    void setHeight(unsigned int height){ setDimensions(_labelWidth,height);}
    unsigned int getHeight() const { return _labelHeight;}   

    /** Sets the untransformed size of the label in a more efficient way. */
    void setDimensions(unsigned int width,unsigned int height);
    const Size& getDimensions() const{ return _labelDimensions;}
```

There is one more thing we should keep in mind. On default, the line break are word-wise operation which means when a word is reaching the boundary of the dimension,
if the remaining space is not enough for the word, the word will be put into the next new line. You could change this behavior by calling `setLineBreakWithoutSpace(true)` which is character-wise operation
and the word might be divided into two parts.

#### Tips & Tricks
- Please Don't use LabelTTF and LabelBMFont, they are marked as DEPRECATED classes and will be removed in the future.

- When dealing with Label related programming, always stick to the new Label.

- When you want to change the color of the label text ,please use `setTextColor` instead of `setColor`, the latter will change the text color as well as the Shadow/Outline/Glow color. 


### Menu&Menu Items
A `Menu` is a way to navigate through game options. Menus often contain options like 'Play', 'Quit', 'Settings' and 'About'. This is usually in the form of buttons that are pressed.

#### What makes up a menu
A `Menu` is made up of a base node called `Menu`. It is easy to create a `Menu`.

```cpp
auto myMenu = cocos2d::Menu::create();
```        
#### Menu Items and adding to a Menu
`MenuItems` are the meat of any `Menu`.  Menu Items usually have a `normal` and a `selected` state as well as a callback...something that happens when the `MenuItem` is selected.

```cpp
// creating a menu with a single item
auto closeItem = cocos2d::MenuItemImage::create("CloseNormal.png", "CloseSelected.png", CC_CALLBACK_1(HelloWorld::menuCloseCallback, this));

cocos2d::Mneu* menu = cocos2d::Menu::create(closeItem, NULL);
this->addChild(menu, 1);

// creating a Menu from a Vector of items
cocos2d::Vector<cocos2d::MenuItem*> MenuItems;

auto closeItem = cocos2d::MenuItemImage::create("CloseNormal.png", "CloseSelected.png", CC_CALLBACK_1(HelloWorld::menuCloseCallback, this));

MenuItems.pushBack(closeItem);

/* repeat for as many menu items as needed */

auto menu = cocos2d::Menu::createWithArray(MenuItems);
this->addChild(menu, 1);
```
#### Lambdas as Menu callback
A lambda function is a function that you can write inline in your source code. Cocos2d-x makes use of Lambdas. You can even use them as callbacks!
```cpp
// a simple lambda
auto func = [] () { cout << "Hello world"; };
func(); // now call the function

// creating a CallFunc with a lambda
auto action1 = cocos2d::CallFunc::create(
[&](){
        std::cout << "using a Lambda callback" << std::endl;
    });
    
// creating an std::function using a lambda
std::function<void()> myFunction = []()
{
        std::cout << "From myFunction()" << std::endl;
};
auto action2 = cocos2d::CallFunc::create(myFunction);

// creating a MenuItemImage with a lambda callback
auto closeItem = cocos2d::MenuItemImage::create("CloseNormal.png", "CloseSelected.png", [&](cocos2d::Ref* sender){
                        // your code here
                     });
```

#### Limitations
Menu uses scene graph touch event listener to handle touch events, so the touch event could be handled properly when overlay occurs between menuItems and only the menuItem which has the highest ZOrder will receive the touch event.

But it works badly with ScrollView, PageView and ListView, when the menuItem is outside of the clipping area of these parent container, the touch is still handled which is really weird.


### TextFieldTTF
TextFieldTTF is a simple class for inputting text. It's a OpenGL implementation and works on all platform that cocos2d-x supports.
In fact, it's just a simple Label plus a few IME features.

Here is the class declaration:

```cpp
class CC_DLL TextFieldTTF : public Label, public IMEDelegate
{
    //other 
}
```

So TextField supports all the features of Label, such as Text Alignment, Line Wrap and Outline/Shadow/Glow effect in theory.

We could use the following method to create a TextFieldTTF with a predefined place holder:

```cpp
    _textField = TextFieldTTF::textFieldWithPlaceHolder("<click here for input>",
        FONT_NAME, //FONT_NAME is integer const define
        FONT_SIZE); //FONT_SIZE is also a integer const define
    //add _textField to the scene graph
    addChild(_textField);

    _textField->setDelegate(this);
    _textField->setPosition(Vec2(s.width / 2, s.height / 2));
```

After the TextFieldTTF instance has been added to the scene graph, you must call the following method to pop up the keyboard for inputting.

```cpp
_textField->attachWithIME();
```

Similarly we could call the following method to close the keyboard.

```cpp
_textField->detachWithIME();
```

We could also implement the TextFieldDelegate to get notifications when the the Keyboard is attached or detached and also the input text event and delete text event.

Here is the full interface explanation:

```cpp
    /**
    @brief    If the sender doesn't want to attach to the IME, return true;
    */
    virtual bool onTextFieldAttachWithIME(TextFieldTTF * sender)
    
    /**
    @brief    If the sender doesn't want to detach from the IME, return true;
    */
    virtual bool onTextFieldDetachWithIME(TextFieldTTF * sender)

    /**
    @brief    If the sender doesn't want to insert the text, return true;
    */
    virtual bool onTextFieldInsertText(TextFieldTTF * sender, const char * text, size_t nLen)
    
    /**
    @brief    If the sender doesn't want to delete the delText, return true;
    */
    virtual bool onTextFieldDeleteBackward(TextFieldTTF * sender, const char * delText, size_t nLen)
```

## Control Extensions, extension::EditBox, extension::ScrollView and extension::TableView
### Overview
In this section, we will talk about all the Controls under `extensions/GUI/CCControlExtension` plus extra more discuss of extension::Scale9Sprite, extension::ScrollView, extension::TableView and extension::EditBox.

All of these classes are under cocos2d::extension namespace so if you want to use them ,please include the right header file and import the namespace:

```cpp
    #include"cocos-ext.h"
    using namespace cocos2d::extension.
```

### Control Extensions
The Control Extensions module was original designed for CocosBuilder and now it is not the recommended way to handling GUI programming and we don't plan to add any new features to these controls. So use them under your own risk.

There are many controls, such as ControlButton, ControlColorPicker, ControlSlider, ControlSwitch etc. Since they are not the recommended ways to handling UI programming, so we don't want to give more explanation to them. For more usage information, pleases refer to the [tests](https://github.com/cocos2d/cocos2d-x/tree/v3/tests/cpp-tests/Classes/ExtensionsTest/ControlExtensionTest).

**Limitation**: It doesn't handle touch event properly when controls become invisible only because they are outside of parent container's clipping area.

### extension::Scale9Sprite
This class is marked as DEPRECATED since v3.3 beta and it is just a typedef of ui::Scale9Sprite.

```cpp
CC_DEPRECATED_ATTRIBUTE typedef ui::Scale9Sprite Scale9Sprite;
```

For more document of extension::Scale9Sprite, please refer to [ui::Scale9Sprite](#scale9sprite) section.


### extension::ScrollView
A ScrollView is a Layer which has a clipping area and an inner container with a fixed bounding area. We could add any node descendants to the ScrollView.
In fact, all the nodes are added into the inner container. We could drag the inner container to move it around. When some elements become outside of the clipping area, they will become invisible automatically which is really handy when display content large than the current screen size.

Here we could use the following method to create a ScrollView:

```cpp

    auto sprite = Sprite::create("HelloWorld.png");
    // the Size parameter is the clipping area size
    auto scrollView = ScrollView::create(Size(200,200));
    //we only create horizontal scroll enabled scrollview
    scrollView->setDirection(ScrollView::Direction::HORIZONTAL);
    scrollView->setPosition(Vec2(100,100));
    this->addChild(scrollView);
    //add a sprite to the scrollview, if the sprite's content size is larger than the clipping area of scrollview, only part of the sprite inside the clipping area will be visible
    scrollView->addChild(sprite);
```

The implementation of extension::ScrollView is not very godd and the scroll behavior is also not very natural. So we designed a new ui::ScrollView instead. It has more features than the extension::ScrollView. In the future, the class will also be DEPRECATED.

### extension::TableView
The extension::TableView is a very basic, minimal implementation to bring UITableView-like component into cocos2d-x.

It's a subclass of extension::ScrollView. It needs a DataSource delegate as the data input. 

When display data item, it will reuse TableCells when needed to increase the performance. So when you want to display a large portion of data, the extension::TableView is a good option here.

If you want to use extension::TableView, you must implement the `TableViewDataSource` delegate at first.

**Note**: Because we don't want to put UI code scatter cross the whole engine, so it will be merge into the UI module in the near future and more features will be added after the merging.

In the following code, besides the DataSource protocol, we have also implemented the TableViewDelegate protocol which is used for handling which TableCell is been touched.

```cpp

class TableViewTestLayer : public cocos2d::Layer,public cocos2d::extension::TableViewDataSource, public cocos2d::extension::TableViewDelegate{
   //other stuff is omitted
    
    //TableViewDelegate method
    virtual void scrollViewDidScroll(cocos2d::extension::ScrollView* view) {};
    virtual void scrollViewDidZoom(cocos2d::extension::ScrollView* view) {}
    //TableViewDataSource method
    virtual void tableCellTouched(cocos2d::extension::TableView* table, cocos2d::extension::TableViewCell* cell);
    virtual cocos2d::Size tableCellSizeForIndex(cocos2d::extension::TableView *table, ssize_t idx);
    virtual cocos2d::extension::TableViewCell* tableCellAtIndex(cocos2d::extension::TableView *table, ssize_t idx);
    virtual ssize_t numberOfCellsInTableView(cocos2d::extension::TableView *table);
};

void TableViewTestLayer::tableCellTouched(TableView* table, TableViewCell* cell)
{
    CCLOG("cell touched at index: %ld", cell->getIdx());
}

Size TableViewTestLayer::tableCellSizeForIndex(TableView *table, ssize_t idx)
{
    if (idx == 2) {
        return Size(100, 100);
    }
    return Size(60, 60);
}

TableViewCell* TableViewTestLayer::tableCellAtIndex(TableView *table, ssize_t idx)
{
    auto string = String::createWithFormat("%ld", idx);
    TableViewCell *cell = table->dequeueCell();
    if (!cell) {
        cell = new (std::nothrow) CustomTableViewCell();
        cell->autorelease();
        auto sprite = Sprite::create("Images/Icon.png");
        sprite->setAnchorPoint(Vec2::ZERO);
        sprite->setPosition(Vec2(0, 0));
        cell->addChild(sprite);

        auto label = Label::createWithSystemFont(string->getCString(), "Helvetica", 20.0);
        label->setPosition(Vec2::ZERO);
		label->setAnchorPoint(Vec2::ZERO);
        label->setTag(123);
        cell->addChild(label);
    }
    else
    {
        auto label = (Label*)cell->getChildByTag(123);
        label->setString(string->getCString());
    }


    return cell;
}

ssize_t TableViewTestLayer::numberOfCellsInTableView(TableView *table)
{
    return 20;
}
```

Here is the code to create TableView: we create a TableView with size 60 * 250 and set the TableViewDataSource to the `this` pointer which is a TableViewTestLayer instance. Then we set the ScrollDirection to VERTICAL. we also the delegate class to the TableViewTestLayer. At last, we call `reloadData` method to tell the TableView to fill in the control with the data from TableViewdataSource.

```cpp
	tableView = TableView::create(this, Size(60, 250));
	tableView->setDirection(ScrollView::Direction::VERTICAL);
	tableView->setPosition(Vec2(winSize.width-150,winSize.height/2-120));
	tableView->setDelegate(this);
	tableView->setVerticalFillOrder(TableView::VerticalFillOrder::TOP_DOWN);
	this->addChild(tableView);
	tableView->reloadData();
```

### extension::EditBox
This class is marked as DEPRECATED since v3.3 beta and it is just a typedef of ui::EditBox:

```cpp
CC_DEPRECATED_ATTRIBUTE typedef ui::EditBox EditBox;
CC_DEPRECATED_ATTRIBUTE typedef ui::EditBoxDelegate EditBoxDelegate;
```

For more document of extension::EditBox, please refer to [ui::EditBox](#editbox) section.

## New GUI Module
### Overview

TODO:
1. Talk about the architecture of the New GUI Module.  (The ProtectedNode model and how things are wrapped together.)
2. The advantages of using the new GUI module.
3. Main functionality you might don't want to implement them again and again.
Various Layout options, focus, touch handing(especially with clipping).  slice 9 enabled, ControlState management.


### Buttons
1. the architecture(one ProtectedNode with one Label and three Scale9Sprite)(use diagram)
2. the main functionality(use tables), aka API reference
3. A real world example(some code snippets)
4. Tips and Tricks

### CheckBox
### LoadingBar
### Slider
### ImageView
### Text
### TextBMFont
### TextAtlas
### RichText
### Scale9Sprite
### TextField
### ScrollView
### ListView
### PageView
### Layout
### HBOX & VBox
### Relative Layout
### EditBox


