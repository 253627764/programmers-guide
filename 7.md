# Chapter 7: UI

## Overview
In Cocos2d-x v3.x, we have three ways to deal with GUI programming.

- Label, Menu & MenuItem and TextFieldTTF, which have limited functions. But they are simple and easy to use.

- Control Extensions under extension module plus a simple ScrollView and TableView implementation. It also has a handy EditBox for text input

**Note**:(Now, Since v3.3 beta, the EditBox class has been moved to UI module and the original cocos2d::extensions::EditBox has been marked as DEPRECATED. In the future release of cocos2d-x, the ScrollView and TableView will also be DEPRECATED and we will provide alternative replacement in UI module.).

The Control Extensions exists mainly for CocosBuilder. The parser of CocosBuilder uses this module heavily. There is very handy class in Control Extensions named Scale9Sprite which could help drawing slice 9 enabled sprite on screen. Now the Scale9Sprite is also marked as DEPRECATED and a replacement is ui::Scale9Sprite which has full functionality of the original one plus more features.

- The brand new UI module. The recommended way to handling GUI programming in Cocos2d-x.

So which UI module should I choose when dealing with GUI programming in Cocos2d-x?

There is one rule:

> Always stick to the new UI module, because we also have an [UI editor](http://cocos2d-x.org/products#cocos-studio) to layout your UI elements visually.



## Label, Menu & MenuItem and TextFieldTTF
### Labels
Cocos2d-x v3 has unified the creation of Label into a single API.
There are a few different types of Labels you can choose from.
  
#### BMFont
`BMFont` is a label type that uses a bitmap font. Bitmap fonts consist of a matrix of dots or pixels representing the image of each glyph in each face and size. It is very faster and easy to use, but non-scalable, requiring a separate font for each size.

In order to create a BMFont label, we should provide two files: A fooBar.fnt file and a fooBar.png file.

```cpp
auto myLabel = cocos2d::Label::createWithBMFont("fooBar.fnt", "My Label Text");
```


#### TTF
`TTF` is a label type that uses a True Type Font. You must provide a True Type font file to feed the `Label::createWithTTF` function.

The primary strength of TrueType was originally that it offered font developers a high degree of control over precisely how their fonts are displayed, right down to particular pixels, at various font sizes.

When we create a TTF Label , it will create a 512 * 512 texture at first, when we change the Label text, it will search the character from the cached texture. If not found, it will create a new character and put it into the texture. When it reaches the limit of the texture, we will create another 512 * 512 texture and cache the new character in it. Thus we could keep the memory foot print as minimal as possible and also improve text rendering speed.

So it will not run as fast as BMFont when changing the Label content during game play frequently.

Here is the code to create a TTF Label with "myfont.ttf":

```cpp
auto myLabel = cocos2d::Label::createWithTTF("myfont.ttf", "My Label Text", 16);
```       

We could also use a more complex way to create TTF Labels:

```cpp
TTFConfig labelConfig;
labelConfig.fontFilePath = "myfont.ttf";
labelConfig.fontSize = 16;
//choose the glyphs, which includes DYNAMICï¼Œ NEHE, ASCII and CUSTOM now.
labelConfig.glyphs = GlyphCollection::DYNAMIC;
labelConfig.outlineSize = 0;
labelConfig.distanceFieldEnabled = false;
auto mylabel = cocos2d::Label::createWithTTF(labelConfig, "My Label Text");
```

So it mainly be used for displaying Chart message or some static text information.


#### Label Atlas
`Label Atlas` is a label type that uses texture atlas.

```cpp
auto mylabl = cocos2d::Label::createWithCharMap("fonts/labelatlasimg.png",24,32,'0');
```

Here is the charmap png file, its dimension is 240 * 32 and it contains 10 numbers from 0-9, so each number occupy 24*32.

The 2rd and 3rd arguments of `Label::createWithCharMap` is the itemWith and itemHeight.

![charmap](7/labelatlasimg.png)

You could consider Label Atlas as a simple BMFont with limited font customization. It runs as fast as BMFont and usually used for displaying rapid changing game scores.

         
#### SystemFont
`SystemFont` is a label type that usese the default system font and font size. 

```cpp
auto myLabel3 = cocos2d::Label::createWithSystemFont("My Label Text", "Arial", 16);
```

    


#### Shadow, Outline and Glow
The new Label supports Shadow, Outline and Glow effect, here are the APIs to enable this effect:

```cpp
    /**
     * Enable shadow for the label
     *
     * @todo support blur for shadow effect
     */
    virtual void enableShadow(const Color4B& shadowColor = Color4B::BLACK,const Size &offset = Size(2,-2), int blurRadius = 0);

    /** only support for TTF, the System Font Outline effect only works on Android and IOS
    virtual void enableOutline(const Color4B& outlineColor,int outlineSize = -1);

    /** only support for TTF */
    virtual void enableGlow(const Color4B& glowColor);
```

As we see from the comments part, the Shadow effect is supported for all kind of Label types, but Outline effect only works well on all platform with TTF font, the SystemFont Outline effect only supports IOS and Android and the Glow effect only works with TTF font. That's because we use FreeType2 to rendering TTF font on various platform since v3.0.

#### Text Alignment
The new label support Horizontal and Vertical text alignment. The APIs are very straightforward:

```cpp
    void setAlignment(TextHAlignment hAlignment) { setAlignment(hAlignment,_vAlignment);}
    TextHAlignment getTextAlignment() const { return _hAlignment;}

    void setAlignment(TextHAlignment hAlignment,TextVAlignment vAlignment);

    void setHorizontalAlignment(TextHAlignment hAlignment) { setAlignment(hAlignment,_vAlignment); }
    TextHAlignment getHorizontalAlignment() const { return _hAlignment; }

    void setVerticalAlignment(TextVAlignment vAlignment) { setAlignment(_hAlignment,vAlignment); }
    TextVAlignment getVerticalAlignment() const { return _vAlignment; }
```
#### Line Wrap
The new label also supports *Line Wrap*, you could specify a dimension to your label, when a text line reach the boundary of the dimension, it will automatically break the current line.

```cpp
    /** Sets the untransformed size of the label.
     * The label's width be used for text align if the set value not equal zero.
     * The label's max line width will be equal to the same value.
     */
    void setWidth(unsigned int width) { setDimensions(width,_labelHeight);}
    unsigned int getWidth() const { return _labelWidth; }  

    /** Sets the untransformed size of the label.
     * The label's height be used for text align if the set value not equal zero.
     * The text will display of incomplete when the size of label not enough to support display all text.
     */
    void setHeight(unsigned int height){ setDimensions(_labelWidth,height);}
    unsigned int getHeight() const { return _labelHeight;}   

    /** Sets the untransformed size of the label in a more efficient way. */
    void setDimensions(unsigned int width,unsigned int height);
    const Size& getDimensions() const{ return _labelDimensions;}
```

There is one more thing we should keep in mind. On default, the line break are word-wise operation which means when a word is reaching the boundary of the dimension,
if the remaining space is not enough for the word, the word will be put into the next new line. You could change this behavior by calling `setLineBreakWithoutSpace(true)` which is character-wise operation
and the word might be divided into two parts.

#### Tips & Tricks
- Please Don't use LabelTTF and LabelBMFont, they are marked as DEPRECATED classes and will be removed in the future.

- When dealing with Label related programming, always stick to the new Label.

- When you want to change the color of the label text ,please use `setTextColor` instead of `setColor`, the latter will change the text color as well as the Shadow/Outline/Glow color. 


### Menu&Menu Items
A `Menu` is a way to navigate through game options. Menus often contain options like 'Play', 'Quit', 'Settings' and 'About'. This is usually in the form of buttons that are pressed.

#### What makes up a menu
A `Menu` is made up of a base node called `Menu`. It is easy to create a `Menu`.

```cpp
auto myMenu = cocos2d::Menu::create();
```        
#### Menu Items and adding to a Menu
`MenuItems` are the meat of any `Menu`.  Menu Items usually have a `normal` and a `selected` state as well as a callback...something that happens when the `MenuItem` is selected.

```cpp
// creating a menu with a single item
auto closeItem = cocos2d::MenuItemImage::create("CloseNormal.png", "CloseSelected.png", CC_CALLBACK_1(HelloWorld::menuCloseCallback, this));

cocos2d::Mneu* menu = cocos2d::Menu::create(closeItem, NULL);
this->addChild(menu, 1);

// creating a Menu from a Vector of items
cocos2d::Vector<cocos2d::MenuItem*> MenuItems;

auto closeItem = cocos2d::MenuItemImage::create("CloseNormal.png", "CloseSelected.png", CC_CALLBACK_1(HelloWorld::menuCloseCallback, this));

MenuItems.pushBack(closeItem);

/* repeat for as many menu items as needed */

auto menu = cocos2d::Menu::createWithArray(MenuItems);
this->addChild(menu, 1);
```
#### Lambdas as Menu callback
A lambda function is a function that you can write inline in your source code. Cocos2d-x makes use of Lambdas. You can even use them as callbacks!
```cpp
// a simple lambda
auto func = [] () { cout << "Hello world"; };
func(); // now call the function

// creating a CallFunc with a lambda
auto action1 = cocos2d::CallFunc::create(
[&](){
        std::cout << "using a Lambda callback" << std::endl;
    });
    
// creating an std::function using a lambda
std::function<void()> myFunction = []()
{
        std::cout << "From myFunction()" << std::endl;
};
auto action2 = cocos2d::CallFunc::create(myFunction);

// creating a MenuItemImage with a lambda callback
auto closeItem = cocos2d::MenuItemImage::create("CloseNormal.png", "CloseSelected.png", [&](cocos2d::Ref* sender){
                        // your code here
                     });
```

#### Limitations
Menu uses scene graph touch event listener to handle touch events, so the touch event could be handled properly when overlay occurs between menuItems and only the menuItem which has the highest ZOrder will receive the touch event.

But it works badly with ScrollView, PageView and ListView, when the menuItem is outside of the clipping area of these parent container, the touch is still handled which is really weird.


### TextFieldTTF
TextFieldTTF is a simple class for inputting text. It's a OpenGL implementation and works on all platform that cocos2d-x supports.
In fact, it's just a simple Label plus a few IME features.

Here is the class declaration:

```cpp
class CC_DLL TextFieldTTF : public Label, public IMEDelegate
{
    //other 
}
```

So TextField supports all the features of Label, such as Text Alignment, Line Wrap and Outline/Shadow/Glow effect in theory.

We could use the following method to create a TextFieldTTF with a predefined place holder:

```cpp
    _textField = TextFieldTTF::textFieldWithPlaceHolder("<click here for input>",
        FONT_NAME, //FONT_NAME is integer const define
        FONT_SIZE); //FONT_SIZE is also a integer const define
    //add _textField to the scene graph
    addChild(_textField);

    _textField->setDelegate(this);
    _textField->setPosition(Vec2(s.width / 2, s.height / 2));
```

After the TextFieldTTF instance has been added to the scene graph, you must call the following method to pop up the keyboard for inputting.

```cpp
_textField->attachWithIME();
```

Similarly we could call the following method to close the keyboard.

```cpp
_textField->detachWithIME();
```

We could also implement the TextFieldDelegate to get notifications when the the Keyboard is attached or detached and also the input text event and delete text event.

Here is the full interface explanation:

```cpp
    /**
    @brief    If the sender doesn't want to attach to the IME, return true;
    */
    virtual bool onTextFieldAttachWithIME(TextFieldTTF * sender)
    
    /**
    @brief    If the sender doesn't want to detach from the IME, return true;
    */
    virtual bool onTextFieldDetachWithIME(TextFieldTTF * sender)

    /**
    @brief    If the sender doesn't want to insert the text, return true;
    */
    virtual bool onTextFieldInsertText(TextFieldTTF * sender, const char * text, size_t nLen)
    
    /**
    @brief    If the sender doesn't want to delete the delText, return true;
    */
    virtual bool onTextFieldDeleteBackward(TextFieldTTF * sender, const char * delText, size_t nLen)
```

## Control Extensions, extension::EditBox, extension::ScrollView and extension::TableView
### Overview
In this section, we will talk about all the Controls under `extensions/GUI/CCControlExtension` plus extra more discuss of extension::Scale9Sprite, extension::ScrollView, extension::TableView and extension::EditBox.

All of these classes are under cocos2d::extension namespace so if you want to use them ,please include the right header file and import the namespace:

```cpp
    #include"cocos-ext.h"
    using namespace cocos2d::extension.
```

### Control Extensions
The Control Extensions module was original designed for CocosBuilder and now it is not the recommended way to handling GUI programming and we don't plan to add any new features to these controls. So use them under your own risk.

There are many controls, such as ControlButton, ControlColorPicker, ControlSlider, ControlSwitch etc. Since they are not the recommended ways to handling UI programming, so we don't want to give more explanation to them. For more usage information, pleases refer to the [tests](https://github.com/cocos2d/cocos2d-x/tree/v3/tests/cpp-tests/Classes/ExtensionsTest/ControlExtensionTest).

**Limitation**: It doesn't handle touch event properly when controls become invisible only because they are outside of parent container's clipping area.

### extension::Scale9Sprite
This class is marked as DEPRECATED since v3.3 beta and it is just a typedef of ui::Scale9Sprite.

```cpp
CC_DEPRECATED_ATTRIBUTE typedef ui::Scale9Sprite Scale9Sprite;
```

For more document of extension::Scale9Sprite, please refer to [ui::Scale9Sprite](#scale9sprite) section.


### extension::ScrollView
A ScrollView is a Layer which has a clipping area and an inner container with a fixed bounding area. We could add any node descendants to the ScrollView.
In fact, all the nodes are added into the inner container. We could drag the inner container to move it around. When some elements become outside of the clipping area, they will become invisible automatically which is really handy when display content large than the current screen size.

Here we could use the following method to create a ScrollView:

```cpp

    auto sprite = Sprite::create("HelloWorld.png");
    // the Size parameter is the clipping area size
    auto scrollView = ScrollView::create(Size(200,200));
    //we only create horizontal scroll enabled scrollview
    scrollView->setDirection(ScrollView::Direction::HORIZONTAL);
    scrollView->setPosition(Vec2(100,100));
    this->addChild(scrollView);
    //add a sprite to the scrollview, if the sprite's content size is larger than the clipping area of scrollview, only part of the sprite inside the clipping area will be visible
    scrollView->addChild(sprite);
```

The implementation of extension::ScrollView is not very godd and the scroll behavior is also not very natural. So we designed a new ui::ScrollView instead. It has more features than the extension::ScrollView. In the future, the class will also be DEPRECATED.

### extension::TableView
The extension::TableView is a very basic, minimal implementation to bring UITableView-like component into cocos2d-x.

It's a subclass of extension::ScrollView. It needs a DataSource delegate as the data input. 

When display data item, it will reuse TableCells when needed to increase the performance. So when you want to display a large portion of data, the extension::TableView is a good option here.

If you want to use extension::TableView, you must implement the `TableViewDataSource` delegate at first.

**Note**: Because we don't want to put UI code scatter cross the whole engine, so it will be merge into the UI module in the near future and more features will be added after the merging.

In the following code, besides the DataSource protocol, we have also implemented the TableViewDelegate protocol which is used for handling which TableCell is been touched.

```cpp

class TableViewTestLayer : public cocos2d::Layer,public cocos2d::extension::TableViewDataSource, public cocos2d::extension::TableViewDelegate{
   //other stuff is omitted
    
    //TableViewDelegate method
    virtual void scrollViewDidScroll(cocos2d::extension::ScrollView* view) {};
    virtual void scrollViewDidZoom(cocos2d::extension::ScrollView* view) {}
    //TableViewDataSource method
    virtual void tableCellTouched(cocos2d::extension::TableView* table, cocos2d::extension::TableViewCell* cell);
    virtual cocos2d::Size tableCellSizeForIndex(cocos2d::extension::TableView *table, ssize_t idx);
    virtual cocos2d::extension::TableViewCell* tableCellAtIndex(cocos2d::extension::TableView *table, ssize_t idx);
    virtual ssize_t numberOfCellsInTableView(cocos2d::extension::TableView *table);
};

void TableViewTestLayer::tableCellTouched(TableView* table, TableViewCell* cell)
{
    CCLOG("cell touched at index: %ld", cell->getIdx());
}

Size TableViewTestLayer::tableCellSizeForIndex(TableView *table, ssize_t idx)
{
    if (idx == 2) {
        return Size(100, 100);
    }
    return Size(60, 60);
}

TableViewCell* TableViewTestLayer::tableCellAtIndex(TableView *table, ssize_t idx)
{
    auto string = String::createWithFormat("%ld", idx);
    TableViewCell *cell = table->dequeueCell();
    if (!cell) {
        cell = new (std::nothrow) CustomTableViewCell();
        cell->autorelease();
        auto sprite = Sprite::create("Images/Icon.png");
        sprite->setAnchorPoint(Vec2::ZERO);
        sprite->setPosition(Vec2(0, 0));
        cell->addChild(sprite);

        auto label = Label::createWithSystemFont(string->getCString(), "Helvetica", 20.0);
        label->setPosition(Vec2::ZERO);
		label->setAnchorPoint(Vec2::ZERO);
        label->setTag(123);
        cell->addChild(label);
    }
    else
    {
        auto label = (Label*)cell->getChildByTag(123);
        label->setString(string->getCString());
    }


    return cell;
}

ssize_t TableViewTestLayer::numberOfCellsInTableView(TableView *table)
{
    return 20;
}
```

Here is the code to create TableView: we create a TableView with size 60 * 250 and set the TableViewDataSource to the `this` pointer which is a TableViewTestLayer instance. Then we set the ScrollDirection to VERTICAL. we also the delegate class to the TableViewTestLayer. At last, we call `reloadData` method to tell the TableView to fill in the control with the data from TableViewdataSource.

```cpp
	tableView = TableView::create(this, Size(60, 250));
	tableView->setDirection(ScrollView::Direction::VERTICAL);
	tableView->setPosition(Vec2(winSize.width-150,winSize.height/2-120));
	tableView->setDelegate(this);
	tableView->setVerticalFillOrder(TableView::VerticalFillOrder::TOP_DOWN);
	this->addChild(tableView);
	tableView->reloadData();
```

### extension::EditBox
This class is marked as DEPRECATED since v3.3 beta and it is just a typedef of ui::EditBox:

```cpp
CC_DEPRECATED_ATTRIBUTE typedef ui::EditBox EditBox;
CC_DEPRECATED_ATTRIBUTE typedef ui::EditBoxDelegate EditBoxDelegate;
```

For more document of extension::EditBox, please refer to [ui::EditBox](#editbox) section.

## New GUI Module
### Overview
The new GUI module is a widget-based GUI framework, it was original designed for [CocosStudio](http://www.cocos2d-x.org/wiki/CocoStudio).
It tries to break the stalemate that cocos2d-x lack a well defined, official supported featured GUI solution. We know GUI framework design is a hard topic for us, but we will improve it with the community.

Now it is the only GUI module under actively developed. New features will be added continually and bug report will be quickly responded. So when you are dealing with GUI programming, please give it a try. 

In this section, we show you the architecture of the GUI module and the features it provides.

#### Architecture
The root class of the new GUI module is `ui::Widget` which is inherited from `cocos2d::ProtectedNode`. A ProtectedNode is designed for holding inner Node list such that when you are adding or removing child node from the ProtectedNode, the "Innder Node List" won't be touched which is safe to keep widget's inner rendering components.

We could simply divide the GUI module into two parts:  the general Widgets part and the Container part.

Here is a figure to show you the big picture:

![ui-architecture](7/ui-architecture.png ) 

From the picture, we can see that besides the *container* and *widgets* parts, we also have *misc* and *experimental* parts.

The *misc* part provide some auxiliary function for the rest of UI module, such as slice 9 enabled sprite drawing, find child widget by name recursively etc.

The *experimental* part is intent for putting none cross platform Widgets. The VideoPlyaer and WebView are two very handy and ready to use widget type, but they only works for iOS and Android. We will take about these two Widget later in the end of document.

Now, we will take a look at the *Container* part. Here is the figure:

![ui-container](7/ui-container.png ) 

The `Layout` class is the root class of all containers. It is also inherited from Widget. Layout class exists mainly for arranging children widgets and clipping. It also supports background color and background image which is handy when layout it on a UI editor.

The `LayoutManager`, `LayoutParameter` and `Margin` classes are used for layout elements. `HBox`, `VBox` and `RelativeBox` are handy classes for layout children widgets horizontally, vertically and relatively.

The `ScrolView`, `ListView` and `PageView` are specific containers for certain usage scenario. We will talk it in another section.

At last, we will take a look at the *Widgets* part. It contains many handy widget to help our daily GUI programming.

Here is a figure contains all the widgets:

![ui-detailed](7/ui-detailed.png ) 

We will discuss these widgets in detail in the next sections.


All of these Widget class share the same model below:

![ui-model](7/ui-model.png ) 

They are all ProtectedNode with a few nodes as their inner rendering components. We will talk about the details of each Widget class in detail.


#### Feature List
1. Touch event capturing mimic.
The current touch event model of cocos2d-x only support *bubble* which means the touch event is received at the target node and bubble to its parents. There is no *capture* phase as compare to the DOM event model.

Consider a scenario, we have a ScrollView and a few buttons added, if we click the button, the touch event won't be passed to the ScrollView. If we want to click the button and drag to move the ScrollView, the ScrolView won't be dragged which is not the desired behavior.

The new UI module solve this problem and we could drag the element within ScrollView(ListView,PageView) to move the container.

2. Clipping: stencil VS scissor.
The Layout class and its descendants supports two types of clipping: stencil and scissor.

When we enable clipping, the child element in Layout will only be draw inside the bounds of Layout.

3. UTF8 support
When dealing with text display and text input, UTF8 support is a must have feature. All the text related classes in new UI module support UTF8.

4. Percent positioning and percent content size.
Percent positioning is a handy way to position widget. When you want to positioning the child widget always to the right top corner of its parents. We could simply set the child widget's position type to `PositionType::PERCENT` and set the *PercentPosition* to `Vec2(1,1)`.

Percent content size is similar to percent position. If we want a child widget's content size always equal to the half content size of its partent, we could specify the child widget's size type to `SizeType::PERCENT` and set the *SizePercent* to `Vec2(0.5,0.5)`.


5. Widget state management.
In general, a Widget will contains three state: Normal, Active(Pressed) and Disabled. All the widgets in the new UI module take care of the state management and change their appearance accordingly to the state switch.

6. Widget focus.
When you have a few widgets on the screen, you might want one of them to be focused and you could simply specify the focus change direction, the framework will do the rest for you to move the focus to the next proper widget. This feature is very helpful if you want to use cocos2d-x to program OTT UI interface.

7. Layout widgets
Layout is a must have feature in any UI framework. Currently the new UI module supports Horizontal, Vertical and Relative Layout.
We could also specify the *Margin* property of each widget, these proper will be calculated during layouting.

If you don't want to implement these features by yourself, you might give the new UI module a try.



### Buttons
A button intercepts touch event and calls a predefined callback when tapped. It is inherited from `ui::Widget`. This class provide methods for setting the title, image and other properties to meet your own needs.

#### Architecture
A button is a ProtectedNode node along with a few inner rendering components, here is the figure:

![ui-button](7/ui-button.png ) 

On default, the title of the button is displayed and only the normal state sprite will be displayed. When you tap the button, the state will change to *pressed* and its appearance will be changed accordingly.


#### Example
Here is the code to create a button with two images, a title and a callback.

```cpp
    // the third parameter is optional
    Button* button = Button::create("cocosui/animationbuttonnormal.png",
                                        "cocosui/animationbuttonpressed.png");
    button->setTitleText("Text Button");
    button->setPosition(Point(widgetSize.width / 2.0f, widgetSize.height / 2.0f));
    // here we could also pass a lambda as callback
    button->addTouchEventListener(CC_CALLBACK_2(UIButtonTest::touchEvent, this));        
    this->addChild(button);
```

For more usage tests, please refer to [UIButtonTest](https://github.com/cocos2d/cocos2d-x/blob/v3/tests/cpp-tests/Classes/UITest/CocoStudioGUITest/UIButtonTest/UIButtonTest.cpp) for more information.

#### Tips and tricks
On default, when you tap a button, it will zoom to a specified size. You could call `setZoomScale` to change the default behavior.

### CheckBox
A checkbox permits the user to make a binary choice.

#### Architecture
A checkbox contains five node as its inner rendering components.

![ui-checkobx](7/ui-checkbox.png ) 

These five components are explained as below:

-  groundBoxNormal
![goundboxNormal](7/check_box_normal.png ) 

- groundBoxSelected
![grondboxselectd](7/check_box_normal_press.png ) 

- groundBoxDisabled
![groundboxdisabled](7/check_box_normal_disable.png)

- frontCrossNormal
![frontCrossNormal](7/check_box_active.png )

- frontCrossDisabled
![frontCrossDisabled](7/check_box_active_disable.png ) 


#### Example
Here is the code snippets to create a simple checkBox:

```cpp
        // Create the checkbox
        CheckBox* checkBox = CheckBox::create("cocosui/check_box_normal.png",
                                              "cocosui/check_box_normal_press.png",
                                              "cocosui/check_box_active.png",
                                              "cocosui/check_box_normal_disable.png",
                                              "cocosui/check_box_active_disable.png");
        checkBox->setPosition(Vec2(widgetSize.width / 2.0f, widgetSize.height / 2.0f));
        //when user check or uncheck the widget, the following callback will be called. 
        checkBox->addEventListener(CC_CALLBACK_2(UICheckBoxTest::selectedEvent, this));
        _uiLayer->addChild(checkBox);
```

### LoadingBar
A loading bar could be used to visualize the progression of an operation, such as download, file transfer etc.
The loading bar has two direction(LEFT or RIGHT).

#### Architecture
The LoadingBar contains a Scale9Sprite as its progress indicator, here is the figure to show you the relationship:

![loadingbar](7/ui-loadingbar.png ) 


#### Example
Here is the code snippet to create a loading bar:

```cpp
        // Create the loading bar
        LoadingBar* loadingBar = LoadingBar::create("cocosui/sliderProgress.png");
        loadingBar->setDirection(LoadingBar::Direction::RIGHT);
        loadingBar->setPosition(Vec2(widgetSize.width / 2.0f,
                                      widgetSize.height / 2.0f + loadingBar->getContentSize().height / 4.0f));
        _uiLayer->addChild(loadingBar);
```


### Slider
A Slider(track bar) allows user to set value by moving a indicator.

#### Architecture
A slider contains a Scale9Sprite as background and a Scale9Sprite as the progress indicator. It also contains a ball to allow user touch and drag. The ball renderer is just a Node with three Sprites as children.

Here is the figure to show you the inner rendering components of Slider:

![slider](7/ui-slider.png ) 


#### Example
Here is the code snippet to create a slider :

```cpp
        Slider* slider = Slider::create();
        slider->loadBarTexture("cocosui/sliderTrack.png");
        slider->loadSlidBallTextures("cocosui/sliderThumb.png", "cocosui/sliderThumb.png", "");
        slider->loadProgressBarTexture("cocosui/sliderProgress.png");
        slider->setPosition(Vec2(widgetSize.width / 2.0f, widgetSize.height / 2.0f/* + slider->getSize().height * 2.0f*/));
        slider->addEventListener(CC_CALLBACK_2(UISliderTest::sliderEvent, this));
        _uiLayer->addChild(slider);
```


### ImageView
#### Architecture
#### Example
### Text
#### Architecture
#### Example
### TextBMFont
#### Architecture
#### Example
### TextAtlas
#### Architecture
#### Example
### RichText
#### Architecture
#### Example
### Scale9Sprite
#### Architecture
#### Example
### TextField
#### Architecture
#### Example
### ScrollView
#### Architecture
#### Example
### ListView
#### Architecture
#### Example
### PageView
#### Architecture
#### Example
### Layout
#### LayoutParameter
#### LayoutManger
#### Example
### HBOX & VBox
#### Example
### Relative Layout
#### Example
### EditBox
#### Example
### UIHelper
#### Example
### VideoPlyaer
### WebView



### Limitation
1. Currently the RichText widget doesn't support clickable item and doesn't support manually line break.

2. The TextField widget doesn't support "input cursor blink" and it won't move the content when keyboard appears.
If you want a system control, you might want to use EditBox at the moment.

3. ListView doesn't support DataSource and also doesn't support item reuse. When display large amount data, it will not performance good. At this time, you might want to use extension::TableView stead. (In the future, we will merge the extension::tableView to the new UI module)
