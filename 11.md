# Chapter 11: Lua

## Call custom c++ from Lua
cocos2d-x lua binds c++ class, class functions ,enum and some global functions to lua through auto-binding by bindings-generator(tools/bindings-generator) and some manual binding,so we can call custom c++ from lua conveniently.
### Call the class member function

Open the `lua-empty-test/src/hello.lua` file and we will find many function calls like `cc.***`. They are actually calling the class member function.Let we see the `initGLView` function.

```
local function initGLView()
    local director = cc.Director:getInstance()
    local glView = director:getOpenGLView()
    if nil == glView then
        glView = cc.GLViewImpl:create("Lua Empty Test")
        director:setOpenGLView(glView)
    end

    director:setOpenGLView(glView)

    glView:setDesignResolutionSize(480, 320, cc.ResolutionPolicy.NO_BORDER)

    director:setDisplayStats(true)

    director:setAnimationInterval(1.0 / 60)
end

```

The relationship between the lua function call and the c++ function call as follow:

```
|          lua                         |        c++                          |
|  cc.Director:getInstance()           |    cocos2d::Director::getInstance() |
|  director:getOpenGLView()            |    director->getOpenGLView          |
|  cc.GLViewImpl:create("Lua Empty Test") | cocos2d::GLViewImpl::create("Lua Empty Test") |
|  glView:setDesignResolutionSize(480, 320, cc.ResolutionPolicy.NO_BORDER) | glview->glView:setDesignResolutionSize(480, 320, ResolutionPolicy::NO_BORDER)|
```

From this table,we can see that the functions called in the lua are very similar with the functions called in the c++, and there are some key points that we need to pay attention to as follow: 

- `cc` is a moudle name like namespace name in c++,it is cocos2d-x 3.0 new features.The relation between the lua modules and c++ namespaces as follow:

```
|   Lua module name   |   c++ namespace |
|        cc           | cocos2d,cocos2d::extension,CocosDenshion,cocosbuilder |
|       ccui          |  cocos2d::ui    |
|        ccs          |  cocostudio,cocostudio::timeline |
|        sp           |     spine       |
|       ccexp         | cocos2d::experimental,cocos2d::experimental::ui |
```

- No matter the functions are static or not in the c++, the functions called in the lua are all used `:`
- `cc.ResolutionPolicy.NO_BORDER` corresponds to `ResolutionPolicy::NO_BORDER` which is enum value in the c++.Owing to faulty of current bindings-generator, enum values are bound to lua by manual.Different moudles have different lua file to keep the bindings value,the details as follows:

```
    |  moudle name |  const value files |
    |    cc        |  Cocos2dConstants.lua, ExtensionConstants.lua, NetworkConstants.lua|
    |   ccui       |  GuiConstants.lua |
    |    ccs       |  StudioConstants.lua|
    |   ccexp      |  experimentalUIConstants.lua|
```
- For some functions, their parameters include cocos2d::Vec2, cocos2d::Vec3 ,and so on, we should do a conversion to call c++ function.For example:
  
`
    void Node::setPosition(const Vec2& position)
`

In C++, we should call this function like this:

`
	nodeObj->setPosition(Vec2(0.0f, 0.0f))
`

In lua, we should call this function like this:

`
nodeObj:setPosition(cc.p(0.0, 0.0))
`

`cc.p(0.0, 0.0) is to construct an anonymous table like this {x = 0, y =0}`

The other parametric types should be converted are listed as follow:

```
	|  parametric types    |   lua conversional format    |
	|   cocos2d::Point     |   {x = numValue, y = numValue} |
	|   cocos2d::Vec3      |   {x = numValue, y = numValue, z = numValue} |
	|   cocos2d::Vec4      |   {x = numValue, y = numValue, z = numValue, w = numValue} |
	|   cocos2d::Rect      |   {x = numValue, y = numValue, width = numValue, height = numValue} |
	|   cocos2d::Size      |   {width = numValue, height = numValue} |
	|   cocos2d::Color4B   |   {r = numValue, g = numValue, b = numValue, a = numValue} |
	|   cocos2d::Color4F   |   	{r = numValue, g = numValue, b = numValue, a = numValue} |
	|   cocos2d::Color3B   |   	{r = numValue, g = numValue, b = numValue} |
	|   cocos2d::PhysicsMaterial | {density = numValue, restitution = numValue, friction = numValue} |
	|   cocos2d::AffineTransform | {a = numValue, b = numValue, c = numValue, d = numValue, tx = numValue, ty = numValue} |
	|   cocos2d::FontDefinition | {fontName = stringValue, fontSize = numValue, fontAlignmentH = numValue, fontAlignmentV = numValue, fontFillColor = {r = numValue, g = numValue, b = numValue}, fontDimensions = {width = numValue, height = numValue}, shadowEnabled = boolValue[,shadowOffset = {width = numValue, height = numValue}, shadowBlur = numValue, shadowOpacity = numValue], strokeEnabled = boolValue[,strokeColor  = 	{r = numValue, g = numValue, b = numValue}, strokeSize = numValue]} |
	|  cocos2d::Vector | {objValue1,objValue2,...,objValuen,...}|
	|  cocos2d::Map<std::string, T>| {key1 = objValue1, key2 = objValue2,..., keyn = objValuen,...} |
	|  cocos2d::Value | {objValue1,objValue2,...,objValuen,...} or key1 = objValue1, key2 = objValue2,..., keyn = objValuen,...} or stringValue or boolValue or numValue |
	|  cocos2d::ValueMap | {key1 = Value1, key2 = Value2,..., keyn = Valuen,...} |
	|  cocos2d::ValueMapIntKey | {numKey1 = Value1, intKey2 = Value2, ...,intKeyn = Valuen,...} |
	|  cocos2d::ValueVector    | {Value1, Value2, ..., Valuen, ...} |
	|  std::vector<string> |   {stringValue1, stringValue2, ..., stringValuen, ...}   |
	|  std::vector<int>    |   {numValue1, numValue2, ..., numValuen, ...}   |
	|  std::vector<float>  |   {numValue1, numValue2, ..., numValuen, ...}   |
	|  std::vector<unsigned short> | {numValue1, numValue2, ..., numValuen, ...} |
	|  cocos2d::Mat4  | {numValue1,numValue2,..., numValue16} |
	|  cocos2d::TTFConfig |{fontFilePath = stringValue, fontSize = numValue, glyphs = numValue, customGlyphs = stringValue, distanceFieldEnabled = boolValue, outlineSize = numValue}
	| cocos2d::MeshVertexAttrib| {size = numValue, type = numValue, vertexAttrib = numValue, vertexAttrib =numValue} |
	| cocos2d::BlendFunc | { src = numValue, dst = numValue} |
```
 
### Call global functions
cocos2d-x v3 also binds some global functions to lua by manual, such as `kmGLPushMatrix`, `kmGLTranslatef` and `kmGLLoadMatrix` etc.We can call these global function in the lua as follows:

```
	kmGLPopMatrix()
```

### Call OpenGL functions
cocos2d-x v3 binds some OpenGL functions to Lua.All the OpenGL functions are in the `gl` moudle,and we can call OpenGL functions in the lua like this:

```
	local glNode  = gl.glNodeCreate()
	glNode:setContentSize(cc.size(256, 256))
    glNode:setAnchorPoint(cc.p(0.5, 0.5))
    uniformCenter = gl.getUniformLocation(program,"center")
    uniformResolution  = gl.getUniformLocation( program, "resolution")
```

You can refer to `lua-tests/DrawPrimitiveTest` and `lua-tests/OpenGLTest` for more information.

### Summarize
From what has been discussed above, you can find that calling c++ functions from lua is conveniently, and you can refer to `lua-tests` for more detail information.

 
## Bind a c++ class to lua by bindings-generator automatically
Since cocos2d-x v3.0,we use [bindings-generator](https://github.com/cocos2d/bindings-generator) to bind c++ class to lua automatically.

The bindings-generator is based on tolua++, you could config the ini file in the `tools/tolua` directory and then run the genbindings.py script to generate the binding code. By using this method, it greatly reduce the configuration work of writing pkg files which used in cococ2d-x v2.

Next,let's take a custom class as an example to show how to use the bindings-generator to bind a c++ class to lua

### Create a custom class

Here is the code snippets:

```
// CustomClass.h

#ifndef __CUSTOM__CLASS

#define __CUSTOM__CLASS

#include "cocos2d.h"

namespace cocos2d {
class CustomClass : public cocos2d::Ref
{
public:

    CustomClass();

    ~CustomClass();

    static cocos2d::CustomClass* create();

    bool init();

    CREATE_FUNC(CustomClass);
};
} //namespace cocos2d

#endif // __CUSTOM__CLASS
``` 

Note: 

- We omit the cpp file because the bindings-generator only scan the header files
- We suggest that the custom class should be inheritent from cocos2d::Ref class,it is mainly due to the fact that the destructor of cocos2d::Ref would call `removeScriptObjectByObject` to reduce reference count of userdata which create in the c++ automaticly to avoid the memory leak.

### Add a new cocos2dx_custom.ini file

Navigate to the tools/lua folder and create a new file named cocos2dx_custom.ini,the detail of cocos2dx_custom.ini is as follows:

```
[cocos2dx_custom]

# the prefix to be added to the generated functions. You might or might not use this in your own

# templates

prefix = cocos2dx_custom

# create a target namespace (in javascript, this would create some code like the equiv. to `ns = ns 

# all classes will be embedded in that namespace

target_namespace = cc

android_headers =  -I%(androidndkdir)s/platforms/android-14/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/include

android_flags = -D_SIZE_T_DEFINED_ 

clang_headers = -I%(clangllvmdir)s/lib/clang/3.3/include

clang_flags = -nostdinc -x c++ -std=c++11 -U __SSE__

cocos_headers = -I%(cocosdir)s/cocos -I%(cocosdir)s/my -I%(cocosdir)s/cocos/2d -I%(cocosdir)s/cocos/base -I%(cocosdir)s/cocos/ui -I%(cocosdir)s/cocos/physics -I%(cocosdir)s/cocos/2d/platform -I%(cocosdir)s/cocos/2d/platform/android -I%(cocosdir)s/cocos/math/kazmath -I%(cocosdir)s/extensions -I%(cocosdir)s/external -I%(cocosdir)s/cocos/editor-support -I%(cocosdir)s

cocos_flags = -DANDROID -DCOCOS2D_JAVASCRIPT

cxxgenerator_headers = 

# extra arguments for clang

extra_arguments =  %(android_headers)s %(clang_headers)s %(cxxgenerator_headers)s %(cocos_headers)s %(android_flags)s %(clang_flags)s %(cocos_flags)s %(extra_flags)s 

# what headers to parse

headers = %(cocosdir)s/cocos/my/CustomClass.h

# what classes to produce code for. You can use regular expressions here. When testing the regular
# expression, it will be enclosed in "^$", like this: "^Menu*$".

classes = CustomClass.*

# what should we skip? in the format ClassName::[function function]
# ClassName is a regular expression, but will be used like this: "^ClassName$" functions are also
# regular expressions, they will not be surrounded by "^$". If you want to skip a whole class, just
# add a single "*" as functions. See bellow for several examples. A special class name is "*", which
# will apply to all class names. This is a convenience wildcard to be able to skip similar named
# functions from all classes.

skip =

rename_functions = 

rename_classes = 

# for all class names, should we remove something when registering in the target VM?

remove_prefix = 

# classes for which there will be no "parent" lookup

classes_have_no_parents = 

# base classes which will be skipped when their sub-classes found them.

base_classes_to_skip =

# classes that create no constructor

# Set is special and we will use a hand-written constructor

abstract_classes =

# Determining whether to use script object(js object) to control the lifecycle of native(cpp) object or the other way around. Supported values are 'yes' or 'no'.

script_control_cpp = no
```

All of the config files under `tools/tolua` are the same format. Here is the list which you should care when writing your own ini file:

- [title]: To config the title which will by used by the *tools/tolua/gengindings.py* scripts. Generally, the title could be the file name.
- prefix: To config the prefix of a function name, generally, we also use the file name as the prefix.
- target_namespace: To config the module name in the lua. Here we use the `cc` as the module name, when you want to use `CustomClass` in the lua, you must put a prefix named `cc` in front of the name. For example, the `CustomClass` could be reference as `cc.CustomClass`.
- headers: To config all the header files needed for parsing and the %(cocosdir)s is the engine root path of cocos2d-x.
- classes: To config all the classes needed to bind. Here it supports regular expression. So we could set MyCustomClass.* here. For looking more specified usage, you could ref to `tools/tolua/cocos2dx.ini`.
- skip: To config the functions needed to be omit. Now the bindings-generator can't parse `void*` type and also the delegate type, so these types needed to be bind manually. And at this circumstance, you should omit all these types first and then to bind them manually. You could ref to the config files under path `cocos/scripting/lua-bindings/auto` .

- rename_functions: To config the functions need to be renamed in the scripting layer. Due to some reasons, developers want more scripting friendly API, so the config option is for this purpose.

- rename_classes: Not used any more.

- remove_prefix: Not used any more.

- classes_have_no_parents: To config  the parent class needed to be filter. This option is seldom modified.

- abstract_classes: To config the classes whose public constructor don't need to be exported.

- script_control_cpp:yes.  To config whether the scripting layer manage the object life time or not. If no, then the c++ layer cares about their life time.
Now, it is imperfect to control native object's life time in scripting layer. So you could simply leave it to *no*.

## subclassing
    
## Placeholders for: memory management, Debug a Lua Game


